name: Galil
connection: tcp
deviceSadRegex: "(?)"
errorNotifier: "*"
connectionProperties: {
  host: galil1
  port: 23
  timeout: 1000
}
commandMap: {
  // ===== Data Record Commands =====
  // The HCD sends a QR command and returns a CompletedWithResult object containing the values (in a param set)
  getDataRecord: {
    command: QR
    responseFormat: ""
  }
  // The HCD sends a QR command and returns a CompletedWithResult object containing the raw array of bytes for the
  // data record as returned from the device. You can use the DataRecord class to parse the bytes.
  getDataRecordRaw: {
    command: QR
    responseFormat: ""
  }
  
  // ===== Program Execution Commands (NEW INTERFACE) =====
  // Execute an embedded program on a specified thread
  // Example: executeProgram with label="POSA" and thread=1 sends: XQ #POSA,1
  executeProgram: {
    command: "XQ #(label),(thread)"
    responseFormat: ""
  }
  
  // Halt execution of a program on specified thread
  // Example: haltExecution with thread=1 sends: HX 1
  haltExecution: {
    command: "HX (thread)"
    responseFormat: ""
  }
  
  // Upload an embedded program to the controller
  // Reads from specified file in programs directory
  // Example: uploadProgram with filename="sampleHCD_2steppers.dmc"
  uploadProgram: {
    command: "DL"
    responseFormat: ""
  }
  
  // Download all embedded programs from the controller
  // Uses UL command (returns raw program without line numbers)
  // Saves to specified file in runtime programs directory
  // Example: downloadPrograms with filename="current.dmc"
  downloadPrograms: {
    command: "UL"
    responseFormat: ""
  }
  
  // ===== Digital I/O Commands =====
  // Set a digital output bit
  // Example: setBit with address=1 sends: SB 1
  setBit: {
    command: "SB (address)"
    responseFormat: ""
  }
  
  // Clear a digital output bit
  // Example: clearBit with address=1 sends: CB 1
  clearBit: {
    command: "CB (address)"
    responseFormat: ""
  }
  
  // ===== Analog I/O Commands =====
  // Read an analog input channel
  // Example: readAnalogInput with channel=0 sends: MG @AN[0]
  readAnalogInput: {
    command: "MG @AN[(channel)]"
    responseFormat: ".*?([+-]?\\d+\\.\\d+)"
  }
  
  // Write to an analog output channel
  // Example: writeAnalogOutput with channel=1, value=2.5 sends: AO 1,2.5
  writeAnalogOutput: {
    command: "AO (channel),(value)"
    responseFormat: ""
  }
  
  // ===== Utility Commands =====
  // Get error code from controller
  getErrorCode: {
    command: TC0
    responseFormat: ".*?(eCode)"
  }
  
  // Get error description
  getErrorDesc: {
    command: TC1
    responseFormat: "(eCode) (eDesc)"
  }
  
  // Send arbitrary command to controller (for advanced use)
  // This allows sending any DMC command string directly
  sendCommand: {
    command: "(commandString)"
    responseFormat: ""
  }
  
  // Send arbitrary command and return response value
  // Example: sendCommandRV with commandString="MG version" returns version number
  sendCommandRV: {
    command: "(commandString)"
    responseFormat: "(response)"
  }
}

paramDefMap: {
  // ===== Program Execution Parameters =====
  label: {
    type: string
    dataRegex: "([A-Za-z0-9_]+)"
  }
  thread: {
    type: int
    range: "[1,7]"
    dataRegex: "([1-7])"
  }
  programText: {
    type: string
    dataRegex: "(.+)"
  }
  filename: {
    type: string
    dataRegex: "([A-Za-z0-9_.-]+\\.dmc)"
  }
  
  // ===== I/O Parameters =====
  address: {
    type: int
    dataRegex: "(\\d+)"
  }
  channel: {
    type: int
    dataRegex: "(\\d+)"
  }
  value: {
    type: double
    dataRegex: "([+-]?\\d+\\.?\\d*)"
  }
  
  // ===== Error Reporting Parameters =====
  eCode: {
    type: int
    dataRegex: "(\\d{1,2})"
  }
  eDesc: {
    type: string
    dataRegex: "(.+)"
  }
  
  // ===== Generic Command Parameter =====
  commandString: {
    type: string
    dataRegex: "(.+)"
  }
  
  // ===== Command Response Parameter =====
  response: {
    type: string
    dataRegex: "(.+)"
  }
}