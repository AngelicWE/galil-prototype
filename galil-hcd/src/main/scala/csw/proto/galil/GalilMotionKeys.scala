package csw.proto.galil

// This file contains the API for APS and was generated by the icd-db command.
// DO NOT EDIT.
// See https://github.com/tmtsoftware/icd for more information.

import csw.params.core.generics.KeyType._
import csw.params.commands.CommandName
import csw.params.events._
import csw.prefix.models._
import csw.params.core.generics._
import csw.params.core.models._
import csw.params.core.models.Coords._
import csw.time.core.models._

/**
 * Top level API for: APS
 */
//noinspection ScalaUnusedSymbol
object GalilMotionKeys {
  val subsystem = "APS"

  /** API for HCD: APS.ICS.HCD.GalilMotion */
  object `ICS.HCD.GalilMotion` {
    val prefix: Prefix = Prefix(Subsystem.APS, "ICS.HCD.GalilMotion")

    /** Overall HCD status including lifecycle state and global error messages. */
    object CurrentStateCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CurrentState"))

      /** HCD lifecycle state: Uninitialized, Ready, or Faulted. */
      val stateKey: GChoiceKey = ChoiceKey.make("state", "Uninitialized", "Ready", "Faulted")

      /** Numerical ID identifying which APS Galil controller this HCD is managing (1â€“4). */
      val controllerIdKey: Key[Int] = IntKey.make("controllerId")

      /** Global error message, if any. */
      val controllerErrorMsgKey: Key[String] = StringKey.make("controllerErrorMsg")

    }

    /** Status update for axis A including position, velocity, operational state, and error details. */
    object CurrentStateAxisACurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CurrentStateAxisA"))

      /** Current position of axis A (in encoder counts). */
      val positionKey: Key[Float] = FloatKey.make("position", Units.encoder)

      /** Current velocity of axis A (counts/sec). */
      val velocityKey: Key[Float] = FloatKey.make("velocity")

      /** Operational state of axis A: lost, homing, idle, moving, tracking, or error. */
      val axisStateKey: GChoiceKey = ChoiceKey.make("axisState", "lost", "homing", "idle", "moving", "tracking", "error")

      /** True if axis A has reached its target. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Error message for axis A, if any. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

    }

    /** Status update for axis B including position, velocity, operational state, and error details. */
    object CurrentStateAxisBCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CurrentStateAxisB"))

      /** Current position of axis B (in encoder counts). */
      val positionKey: Key[Float] = FloatKey.make("position", Units.encoder)

      /** Current velocity of axis B (counts/sec). */
      val velocityKey: Key[Float] = FloatKey.make("velocity")

      /** Operational state of axis B: lost, homing, idle, moving, tracking, or error. */
      val axisStateKey: GChoiceKey = ChoiceKey.make("axisState", "lost", "homing", "idle", "moving", "tracking", "error")

      /** True if axis B has reached its target. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Error message for axis B, if any. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

    }

    /** Status update for axis C including position, velocity, operational state, and error details. */
    object CurrentStateAxisCCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CurrentStateAxisC"))

      /** Current position of axis C (in encoder counts). */
      val positionKey: Key[Float] = FloatKey.make("position", Units.encoder)

      /** Current velocity of axis C (counts/sec). */
      val velocityKey: Key[Float] = FloatKey.make("velocity")

      /** Operational state of axis C: lost, homing, idle, moving, tracking, or error. */
      val axisStateKey: GChoiceKey = ChoiceKey.make("axisState", "lost", "homing", "idle", "moving", "tracking", "error")

      /** True if axis C has reached its target. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Error message for axis C, if any. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

    }

    /** Status update for axis D including position, velocity, operational state, and error details. */
    object CurrentStateAxisDCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CurrentStateAxisD"))

      /** Current position of axis D (in encoder counts). */
      val positionKey: Key[Float] = FloatKey.make("position", Units.encoder)

      /** Current velocity of axis D (counts/sec). */
      val velocityKey: Key[Float] = FloatKey.make("velocity")

      /** Operational state of axis D: lost, homing, idle, moving, tracking, or error. */
      val axisStateKey: GChoiceKey = ChoiceKey.make("axisState", "lost", "homing", "idle", "moving", "tracking", "error")

      /** True if axis D has reached its target. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Error message for axis D, if any. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

    }

    /** Status update for axis E including position, velocity, operational state, and error details. */
    object CurrentStateAxisECurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CurrentStateAxisE"))

      /** Current position of axis E (in encoder counts). */
      val positionKey: Key[Float] = FloatKey.make("position", Units.encoder)

      /** Current velocity of axis E (counts/sec). */
      val velocityKey: Key[Float] = FloatKey.make("velocity")

      /** Operational state of axis E: lost, homing, idle, moving, tracking, or error. */
      val axisStateKey: GChoiceKey = ChoiceKey.make("axisState", "lost", "homing", "idle", "moving", "tracking", "error")

      /** True if axis E has reached its target. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Error message for axis E, if any. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

    }

    /** Status update for axis F including position, velocity, operational state, and error details. */
    object CurrentStateAxisFCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CurrentStateAxisF"))

      /** Current position of axis F (in encoder counts). */
      val positionKey: Key[Float] = FloatKey.make("position", Units.encoder)

      /** Current velocity of axis F (counts/sec). */
      val velocityKey: Key[Float] = FloatKey.make("velocity")

      /** Operational state of axis F: lost, homing, idle, moving, tracking, or error. */
      val axisStateKey: GChoiceKey = ChoiceKey.make("axisState", "lost", "homing", "idle", "moving", "tracking", "error")

      /** True if axis F has reached its target. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Error message for axis F, if any. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

    }

    /** Status update for axis G including position, velocity, operational state, and error details. */
    object CurrentStateAxisGCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CurrentStateAxisG"))

      /** Current position of axis G (in encoder counts). */
      val positionKey: Key[Float] = FloatKey.make("position", Units.encoder)

      /** Current velocity of axis G (counts/sec). */
      val velocityKey: Key[Float] = FloatKey.make("velocity")

      /** Operational state of axis G: lost, homing, idle, moving, tracking, or error. */
      val axisStateKey: GChoiceKey = ChoiceKey.make("axisState", "lost", "homing", "idle", "moving", "tracking", "error")

      /** True if axis G has reached its target. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Error message for axis G, if any. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

    }

    /** Status update for axis H including position, velocity, operational state, and error details. */
    object CurrentStateAxisHCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CurrentStateAxisH"))

      /** Current position of axis H (in encoder counts). */
      val positionKey: Key[Float] = FloatKey.make("position", Units.encoder)

      /** Current velocity of axis H (counts/sec). */
      val velocityKey: Key[Float] = FloatKey.make("velocity")

      /** Operational state of axis H: lost, homing, idle, moving, tracking, or error. */
      val axisStateKey: GChoiceKey = ChoiceKey.make("axisState", "lost", "homing", "idle", "moving", "tracking", "error")

      /** True if axis H has reached its target. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Error message for axis H, if any. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

    }

    /** Updates for digital inputs, digital outputs, and analog inputs. */
    object InputOutputStateCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("InputOutputState"))

      /** Array of digital input states. */
      val digitalInputsKey: Key[Boolean] = BooleanKey.make("digitalInputs")

      /** Array of digital output states. */
      val digitalOutputsKey: Key[Boolean] = BooleanKey.make("digitalOutputs")

      /** Array of analog input readings. */
      val analogInputsKey: Key[ArrayData[Float]] = FloatArrayKey.make("analogInputs")

    }

    /** Internal status of long-running command execution for axis A. */
    object CommandStateAxisACurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CommandStateAxisA"))

      /** Thread number currently executing the command on axis A (0 if none). */
      val activeThreadKey: Key[Int] = IntKey.make("activeThread")

      /** Error message from the active command on axis A, if present. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

      /** Flag indicating whether axis A has reached the target position. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Flag indicating whether axis A is still moving. */
      val movingKey: Key[Boolean] = BooleanKey.make("moving")

    }

    /** Internal status of long-running command execution for axis B. */
    object CommandStateAxisBCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CommandStateAxisB"))

      /** Thread number currently executing the command on axis B (0 if none). */
      val activeThreadKey: Key[Int] = IntKey.make("activeThread")

      /** Error message from the active command on axis B, if present. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

      /** Flag indicating whether axis B has reached the target position. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Flag indicating whether axis B is still moving. */
      val movingKey: Key[Boolean] = BooleanKey.make("moving")

    }

    /** Internal status of long-running command execution for axis C. */
    object CommandStateAxisCCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CommandStateAxisC"))

      /** Thread number currently executing the command on axis C (0 if none). */
      val activeThreadKey: Key[Int] = IntKey.make("activeThread")

      /** Error message from the active command on axis C, if present. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

      /** Flag indicating whether axis C has reached the target position. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Flag indicating whether axis C is still moving. */
      val movingKey: Key[Boolean] = BooleanKey.make("moving")

    }

    /** Internal status of long-running command execution for axis D. */
    object CommandStateAxisDCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CommandStateAxisD"))

      /** Thread number currently executing the command on axis D (0 if none). */
      val activeThreadKey: Key[Int] = IntKey.make("activeThread")

      /** Error message from the active command on axis D, if present. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

      /** Flag indicating whether axis D has reached the target position. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Flag indicating whether axis D is still moving. */
      val movingKey: Key[Boolean] = BooleanKey.make("moving")

    }

    /** Internal status of long-running command execution for axis E. */
    object CommandStateAxisECurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CommandStateAxisE"))

      /** Thread number currently executing the command on axis E (0 if none). */
      val activeThreadKey: Key[Int] = IntKey.make("activeThread")

      /** Error message from the active command on axis E, if present. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

      /** Flag indicating whether axis E has reached the target position. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Flag indicating whether axis E is still moving. */
      val movingKey: Key[Boolean] = BooleanKey.make("moving")

    }

    /** Internal status of long-running command execution for axis F. */
    object CommandStateAxisFCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CommandStateAxisF"))

      /** Thread number currently executing the command on axis F (0 if none). */
      val activeThreadKey: Key[Int] = IntKey.make("activeThread")

      /** Error message from the active command on axis F, if present. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

      /** Flag indicating whether axis F has reached the target position. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Flag indicating whether axis F is still moving. */
      val movingKey: Key[Boolean] = BooleanKey.make("moving")

    }

    /** Internal status of long-running command execution for axis G. */
    object CommandStateAxisGCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CommandStateAxisG"))

      /** Thread number currently executing the command on axis G (0 if none). */
      val activeThreadKey: Key[Int] = IntKey.make("activeThread")

      /** Error message from the active command on axis G, if present. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

      /** Flag indicating whether axis G has reached the target position. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Flag indicating whether axis G is still moving. */
      val movingKey: Key[Boolean] = BooleanKey.make("moving")

    }

    /** Internal status of long-running command execution for axis H. */
    object CommandStateAxisHCurrentState {
      val eventKey: EventKey = EventKey(prefix, EventName("CommandStateAxisH"))

      /** Thread number currently executing the command on axis H (0 if none). */
      val activeThreadKey: Key[Int] = IntKey.make("activeThread")

      /** Error message from the active command on axis H, if present. */
      val axisErrorMsgKey: Key[String] = StringKey.make("axisErrorMsg")

      /** Flag indicating whether axis H has reached the target position. */
      val inPositionKey: Key[Boolean] = BooleanKey.make("inPosition")

      /** Flag indicating whether axis H is still moving. */
      val movingKey: Key[Boolean] = BooleanKey.make("moving")

    }

    /** Configures motion parameters and inPosition threshold for a given axis. */
    object ConfigAxisCommand {
      val commandName: CommandName = CommandName("configAxis")

      /** The axis to configure (A-H). */
      val axisKey: GChoiceKey = ChoiceKey.make("axis", "A", "B", "C", "D", "E", "F", "G", "H")

      /** Default velocity for the axis. */
      val velocityKey: Key[Float] = FloatKey.make("velocity")

      /** Acceleration value for the axis. */
      val accelerationKey: Key[Float] = FloatKey.make("acceleration")

      /** Deceleration value for the axis. */
      val decelerationKey: Key[Float] = FloatKey.make("deceleration")

      /** Index offset for homing. */
      val indexOffsetKey: Key[Float] = FloatKey.make("indexOffset")

      /** Index speed during homing. */
      val indexSpeedKey: Key[Float] = FloatKey.make("indexSpeed")

      /** Threshold value to determine inPosition status. */
      val inPositionThresholdKey: Key[Float] = FloatKey.make("inPositionThreshold")

    }

    /** Sets the axis as rotating and selects the approach algorithm. */
    object ConfigRotatingAxisCommand {
      val commandName: CommandName = CommandName("configRotatingAxis")

      /** The axis to configure as rotating (A-H). */
      val axisKey: GChoiceKey = ChoiceKey.make("axis", "A", "B", "C", "D", "E", "F", "G", "H")

      /** Approach algorithm for the rotating mechanism. */
      val algorithmKey: GChoiceKey = ChoiceKey.make("algorithm", "forward", "reverse", "shortest")

    }

    /** Configures the axis as linear with defined soft-limit boundaries. */
    object ConfigLinearAxisCommand {
      val commandName: CommandName = CommandName("configLinearAxis")

      /** The axis to configure as linear (A-H). */
      val axisKey: GChoiceKey = ChoiceKey.make("axis", "A", "B", "C", "D", "E", "F", "G", "H")

      /** The upper soft limit for the axis. */
      val upperLimitKey: Key[Float] = FloatKey.make("upperLimit")

      /** The lower soft limit for the axis. */
      val lowerLimitKey: Key[Float] = FloatKey.make("lowerLimit")

    }

    /** Sets or clears a digital output bit at the specified address. */
    object SetBitCommand {
      val commandName: CommandName = CommandName("setBit")

      /** The address of the digital output bit. */
      val addressKey: Key[Int] = IntKey.make("address")

      /** The value to set (0 or 1). */
      val valueKey: Key[Int] = IntKey.make("value")

    }

    /** Sets an analog output channel to the given value. */
    object SetAOCommand {
      val commandName: CommandName = CommandName("setAO")

      /** The address of the analog output channel. */
      val addressKey: Key[Int] = IntKey.make("address")

      /** The value to set on the analog output channel. */
      val valueKey: Key[Float] = FloatKey.make("value")

    }

    /** Initiates the homing sequence for the specified axis. */
    object HomeAxisCommand {
      val commandName: CommandName = CommandName("homeAxis")

      /** The axis to home (A-H). */
      val axisKey: GChoiceKey = ChoiceKey.make("axis", "A", "B", "C", "D", "E", "F", "G", "H")

    }

    /** Moves the specified axis to an absolute target position. */
    object PositionAxisCommand {
      val commandName: CommandName = CommandName("positionAxis")

      /** The axis to move (A-H). */
      val axisKey: GChoiceKey = ChoiceKey.make("axis", "A", "B", "C", "D", "E", "F", "G", "H")

      /** The target position (in encoder counts). */
      val targetKey: Key[Float] = FloatKey.make("target")

    }

    /** Moves the specified axis by a relative distance. */
    object OffsetAxisCommand {
      val commandName: CommandName = CommandName("offsetAxis")

      /** The axis to offset (A-H). */
      val axisKey: GChoiceKey = ChoiceKey.make("axis", "A", "B", "C", "D", "E", "F", "G", "H")

      /** The relative distance to move the axis. */
      val distanceKey: Key[Float] = FloatKey.make("distance")

    }

    /** Positions a rotating mechanism (e.g., filter wheel) based on a discrete selection. */
    object SelectWheelCommand {
      val commandName: CommandName = CommandName("selectWheel")

      /** The axis associated with the rotating mechanism. */
      val axisKey: GChoiceKey = ChoiceKey.make("axis", "A", "B", "C", "D", "E", "F", "G", "H")

      /** The filter number corresponding to the desired wheel position. */
      val positionKey: Key[Int] = IntKey.make("position")

    }

    /** Sets the specified axis into tracking mode with continuous target updates. */
    object TrackAxisCommand {
      val commandName: CommandName = CommandName("trackAxis")

      /** The axis to track (A-H). */
      val axisKey: GChoiceKey = ChoiceKey.make("axis", "A", "B", "C", "D", "E", "F", "G", "H")

      /** Primary tracking target value (e.g., absolute position). */
      val target1Key: Key[Float] = FloatKey.make("target1")

      /** Secondary tracking parameter (e.g., desired velocity). */
      val target2Key: Key[Float] = FloatKey.make("target2")

    }

    /** Stops any active motion on the specified axis. */
    object StopAxisCommand {
      val commandName: CommandName = CommandName("stopAxis")

      /** The axis to stop (A-H). */
      val axisKey: GChoiceKey = ChoiceKey.make("axis", "A", "B", "C", "D", "E", "F", "G", "H")

    }

    /**
     * Initiates fault recovery using the specified severity level. <br /> None: Just clear error messages <br /> Init: Initialize
     * Controller (reload embedded programs, reconnect to hardware) <br /> Minor: Perform a Reset of the controller (and recover).
     * <br /> Major: Perform a Power Cycle of the controller (and recover).
     */
    object FaultResetCommand {
      val commandName: CommandName = CommandName("faultReset")

      /** Fault recovery level to perform. */
      val severityKey: GChoiceKey = ChoiceKey.make("severity", "None", "Init", "Minor", "Major")

    }

  }

}